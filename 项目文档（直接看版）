C++高性能内存池-项目文档
一、需求分析
核心目标：设计一个线程安全的固定大小内存池，解决频繁分配/释放同大小内存场景下的性能瓶颈（如对象池、链表节点管理）。

1、功能需求
（1）支持预分配内存块（构造时指定块的大小和数量），避免运行时频繁系统调用；
（2）提供高效的allocate（）和deallocate（）接口，通过空闲链表管理内存块；
（3）支持多线程并发访问，确保分配/释放操作的原子性；
（4）提供诊断功能（如空闲块数量查询），便于调试和监控；

2、非功能需求
（1）性能：分配/释放速度优于原生new/delete；
（2）安全性：防止内存泄露、重复释放、越界访问等问题；
（3）可维护性：代码模块化，通过元数据跟踪内存块状态；

二、设计方案
1、核心架构
采用预分配内存池+空闲链表的经典设计，主要包含以下模块：
模块/类	功能描述
MemoryPool	核心类，管理内存分配、释放、空闲链表及线程安全锁
MemoryBlock	内部结构体，存储内存块地址（data）、使用状态（isUsed）及链表指针（next）
m_pools	存储预分配的原始内存地址（std::vector<char*>），支持多池扩展
m_blocks	内存块元数据数组(std::vector<MemoryBlock>)，跟踪每个块的状态

2、关键设计决策
（1）固定大小块：每个内存块在构造时确定（m_blockSize），并向上对齐到16字节（MEM_ALIGNMENT），提升CPU访问效率；
（2）空闲链表管理：通过m_head指针指向空闲块链表，分配时从头部取块，释放时插入头部，实现O（1）操作；
（3）线程安全：使用std::mutex确保allocate()和deallocate()的原子性，避免多线程竞争；
（4）禁止拷贝：删除拷贝构造和赋值运算符，防止内存池对象被非法复制；

三、实现细节
1、内存预分配（构造函数）
（1）计算对齐后的块大小：(blockSize + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT - 1)；
（2）一次性分配blockSize*blockCount字节的内存，存入m_pools；
（3）初始化m_blocks数组，将所有块标记为空闲，并通过next指针串联成链表；
// 构造函数核心逻辑示例
MemoryPool::MemoryPool(size_t blockSize, size_t blockCount)
    : m_blockSize(对齐后的块大小), m_blockCount(blockCount), m_head(nullptr), m_blocks(blockCount) {
    char* pool = new char[m_blockSize * blockCount]; // 预分配内存
    m_pools.push_back(pool);
    // 初始化空闲链表：每个块的next指向前一个块，最终m_head指向最后一个块（链表头）
    for (size_t i = 0; i < blockCount; ++i) {
        m_blocks[i].data = pool + i * m_blockSize;
        m_blocks[i].isUsed = false;
        m_blocks[i].next = m_head; // 头插法构建链表
        m_head = &m_blocks[i];
    }
}

2、分配与释放
（1）allocte()：加锁后从空闲链表头部（m_head）取块，更新链表头部并标记块为“已使用”；
（2）deallocate()：验证指针合法性（是否属于当前内存池、是否重复释放），加锁后将块标记为“空闲”并插入空闲链表头部；

3、异常处理
对无效参数（如块大小为0）、内存分配失败（new抛出std::bad::malloc）、重复释放等场景抛出异常，增强健壮性；

四、测试验证
项目通过三类测试验证功能和性能：
1、基础功能测试：分配/释放测试
验证内存块分配后空闲块减少、释放后恢复；
MemoryPool pool(sizeof(double), 5); // 5个8字节块
auto d1 = pool.allocate(); 
auto d2 = pool.allocate(); 
assert(pool.getAvailableBlocks() == 3); // 分配2个，剩余3个
pool.deallocate(d1);
pool.deallocate(d2);
assert(pool.getAvailableBlocks() == 5); // 释放后恢复5个

2、性能对比测试
（1）测试场景：10万次int类型内存分配+释放，对比内存池与new/delete的耗时；
（2）结果：内存池耗时通常比new/delete低50%~80%（系统调用开销减少）；

3、多线程安全测试
（1）测试场景：10个线程并发分配/释放1000个int块，验证无死锁、内存泄漏或数据竞争；
（2）关键验证：所有线程完成后，空闲块数量恢复为初始值（10000），且无重复释放异常；

五、总结
内存池项目通过预分配+空闲链表+线程锁的设计，有效提升了频繁内存操作的性能，同时保证了多线程环境下的安全性。适用于对象池、高频次小内存分配场景，可作为基础组件嵌入大型系统（如服务器框架、游戏引擎）。

六、注意
本项目是边学习边完成的一个内存池项目，还存在很多问题：
1、设计局限性：固定块大小的灵活性不足、缺乏动态扩容机制、线程安全设计的性能瓶颈；
2、功能与安全性隐患：内存泄漏风险、重复释放与越界访问、不支持内存对齐自定义；
3、性能与扩展性问题：空闲链表的遍历效率、不兼容STL容器和智能指针、缺乏内存碎片监控；
4、跨平台与工程化问题：依赖特定编译器/系统、缺乏性能监控与诊断工具。
