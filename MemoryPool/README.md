一、项目名称：**MemoryPool 高性能内存池**

二、项目概述
MemoryPool 是一个基于 C++ 实现的线程安全内存池，专为频繁分配/释放同大小内存块的场景优化（如对象池、链表节点管理等）。通过预分配内存块并使用空闲链表管理，它能显著减少动态内存分配开销（比 new/delete 快 4-7 倍），同时降低内存碎片率，提升多线程程序的并发性能。

三、核心特性
--高效内存管理：预分配固定大小内存块，通过空闲链表实现 O(1) 分配/释放
--线程安全设计：使用互斥锁（std::mutex）确保多线程环境下的原子操作
--内存对齐优化：自动将内存块对齐到 16 字节边界，提升 CPU 访问效率
--防错机制：支持重复释放检测、越界指针校验，提供详细异常信息
--低碎片率：固定块大小设计 + 空闲块复用，避免堆内存碎片化

四、技术架构
内存池核心结构
----------------------------------------------------------------------------------------
│                                    MemoryPool 类                                      |                     
├----------------------------------------------------------------------------------------
│      成员变量      │     核心功能      │                数据结构/实现                    │
├----------------------------------------------------------------------------------------
│ m_blockSize       │ 固定块大小         │ 构造时对齐到16字节                              │
│ m_blockCount      │ 总块数量           │ 预分配内存总量 = 块大小×数量                     │
│ m_head            │ 空闲链表头         │ 指向首个可用块                                   │
│ m_blocks          │ 块元数据数组        │ 跟踪每个块的地址/状态/链表关系                   │
│ m_pools           │ 原始内存池          │ 存储预分配的连续内存块                           │
│ m_mutex           │ 线程安全锁          │ 保护分配/释放操作的原子性                        │
└------------------------------------------------------------------------------------------

内存分配流程
1、初始化：构造函数预分配连续内存，按 m_blockSize 分割为 m_blockCount 个块，并通过 m_blocks 数组构建空闲链表
2、分配（allocate）：
--加锁保护临界区
--从 m_head 指向的空闲链表头部取块
--标记块为“已使用”并返回块地址
3、释放（deallocate）：
--加锁保护临界区
--校验指针合法性（是否属于当前内存池、是否重复释放）
--标记块为“空闲”并重新插入空闲链表头部


五、项目结构
MemoryPool/
├── MemoryPool.h       // 类声明：内存池核心接口与数据结构  
├── MemoryPool.cpp     // 类实现：分配/释放逻辑、内存管理  
└── main.cpp           // 测试程序：基础功能+性能+多线程测试  

六、适用场景
--高频次小内存块分配（如链表、队列、树节点）
--多线程并发内存管理（如服务器、游戏引擎）
--嵌入式系统或对内存碎片敏感的场景

七、注意事项
--内存池仅管理固定大小的块，不支持动态调整块大小
--释放指针时必须确保其指向内存池分配的地址，否则会触发异常
--内存池析构时会自动释放所有预分配内存，无需手动清理

八、许可证
MIT 许可证（详见 LICENSE 文件）

